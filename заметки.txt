Плагины
Установка: npm install -D html-webpack-plugin // отвечате за автоматическое создание в папке /dist index.html файла на основе шаблона

в файле webpack.config.js :

const HTMLWebpackPlugin = require('html-webpack-plugin') // подключаем плагин

...
...
...
,
    plugins: [
        new HTMLWebpackPlugin({ // создаем объект плагина
            template: './src/index.html' // указываем путь к шаблону
        })
    ]
	
54.02 webpack понимает только .js и .json файлы поэтому для работы с другими типами файлов (например .css) нужны loader'ы

1.35.30 установка webpack-dev-server для автоматической перезагрузки страницы при внесении изменений
 - npm i -D webpack-dev-server
 - изменения в webpackconfig.js 
    devServer: {
        port: 4200 // указывает на каком порту будет работать сервер
    },
 - изменения в package.json
 	"start": "webpack-dev-server --mode development --open" // ключ --open для автоматического открытия окна в браузере
 - !!! при использовании webpack-dev-server в папке dist ничего не записываются  - т.к все файлы находятся в опертаивной памяти (для ускорения процесса). Чтобы увидеть файлы проект нужно пересобрать через npm run build/dev

1.40.23 установка copy-webpack-plugin для переноса файлов (папок) из одного места в другое, например favicon.ico из папки /src в  папку /dist.
 - npm i -D copy-webpack-plugin
 - в webpack.config.js дописываем:
	const CopyWebpackPlugin = require('copy-webpack-plugin');
 и в разделе с плагинам добавляем:
         new CopyWebpackPlugin([
            {
                from: path.resolve(__dirname, 'src/favicon.ico'),  // что и из какой папки копируем
                to: path.resolve(__dirname, 'dist') // путь куда скопируется favicon.ico
            }


        ]),

1.43.00 установка mini-css-extract-plugin необходим чтобы стили писались в отдельный файл, а не прописывались в тегах <head><style></style></head>
 - npm i -D mini-css-extract-plugin
 - в webpackconfig.js добавляем:
	const MiniCssExtractPlugin = require('mini-css-extract-plugin');
		и в разделе plugin:
          new MiniCssExtractPlugin({
            filename: '[name].[contenthash]css',
        }),
		
 - в разделе rules добавляем:
	        rules: [
            {   test: /\.css$/, //регулярное выражение для .css файла
                use: [{
                    loader: MiniCssExtractPlugin.loader, // прописываем лоадер
                    options: {
                        hmr: true, // позволяет изменять сущности без перезагрузки страницы
                        reloadAll: true
                    }
                }, 'css-loader']
            },

1.53.00 минификация html и css файлов
 - добавляем в настройки плагина строки 
        new HTMLWebpackPlugin({
            template: './index.html',
            minify: { // минификация .html файла
                collapseWhitespace: true, 
                removeComments: true,
            }


1.54.00 минификация .css файла
 - npm i -D terser-webpack-plugin
 - npm i -D optimize-css-assets-webpack-plugin
 - создаем в начале конфика функция которая в зависимости от значения переменной isProd возвращает в модуль optimization нужное значение

const optimization = () => {
    const config = {
        splitChunks: { 
            chunks: 'all'
        }
    }
    if (isProd) {
        config.minimizer = [
            new OptimizeCssAssetsWebpackPlugin(),
            new TerserWebpackPlugin()
        ]
    }
    return config
}

2.00.00 подключение препроцессора less
 - в блоке rules добавляем новое правило для обработки файлов с расширением .less (по сути копируем правил для css файлов и добавляем обработчик less)
			{   
                test: /\.less$/, //регулярное выражение для .less файла
                use: [{
                    loader: MiniCssExtractPlugin.loader,
                    options: {
                        hmr: isDev,
                        reloadAll: true
                    }
                }, 'css-loader', 'less-loader'] // добавляем обработчик less
            },
 
 -устанавливаем лоадер:
	npm i -D less-loader
 - подключаем .less файл в index.js:
	import './styles/less.less'
 - подключаем библиотеку less:
	npm i -D less
	
2.05.00 делаем  оптимизацию для добавления хэша в имя .css .js файлов в зависимости от режима сборки:
 - const filename = ext => isDev ? `[name].${ext}` : `[name].[hash].${ext}` //фукция принимает параметр ext и в зависимости от значение isDev возвращает имя с хешем или без
 - в конструкторе плагина вызываем filename c сооответсвтующим расширением и при описании точки вывода:
	        new MiniCssExtractPlugin({
            filename: filename('css'), // имя выходного файла
        }),
		
		    output: {
        filename: filename('js'),
        path: path.resolve(__dirname, 'dist')
    },
 
 2.10.00 установка babel
  - npm i -D babel-loader @babel/core
  - добавляем новое правило:
  module: {
  rules: [
    { test: /\.js$/, 
    exclude: /node_modules/, 
    loader: "babel-loader" }
  ]
}
 - для дальнейшего использвания добавляем в поле loader пресеты (presets-env):
 - npm i -D @babel/preset-env
 - в правила дописываем ключ loader: 
            loader: {
            loader: 'babel-loader',
            options: {
                presets: [
                    "@babel/preset-env",
                 ]
            }
        }

- добавляем в package.json строчку:
  "browserslist": "> 0.25%, not dead"  // исользовать для бравзуеров которые не мертсвы и используются блоее .25%
- устанавливаем полифилы:
  npm install --save @babel/polyfill
- добавляем в раздел main @бэйбл/полифил
  main: ['@babel/pollyfill','./index.js'],

2.22.30 добавление плагинов для бейбла для подключения эксперементальных возможностей
 - @babel/plugin-proposal-class-properties 
 - добавляем в раздел options для babel раздел plugins:
        options: {
        presets: [
            "@babel/preset-env",
        ],
        plugins: ['@babel/plugin-proposal-class-properties']

   